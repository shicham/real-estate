name: Deploy api-auth (deploy only — apply manifests if missing)

# Trigger when the CI workflow that builds & pushes the image completes,
# and allow manual runs with an optional image_tag override.
on:
  workflow_run:
    workflows: ["CI - api-auth"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Optional image tag to deploy (overrides package.json)'
        required: false
        default: ''

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deploy to Kubernetes (no docker build/push)
    if: >
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine image tag to deploy
        id: set_image
        run: |
          # If manual run and image_tag provided, use it
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_ENV
            echo "Using manual override image_tag=${{ github.event.inputs.image_tag }}"
            exit 0
          fi

          # Prefer package.json version if available (this should reflect the version pushed by CI)
          if [ -f backend/api-auth/package.json ]; then
            node -e "const fs=require('fs'); const v=require('./backend/api-auth/package.json').version; fs.appendFileSync(process.env.GITHUB_ENV, 'IMAGE_TAG='+v+'\\n'); console.log('IMAGE_TAG='+v)"
          else
            # Fallback to the head SHA of the triggering workflow run (short)
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              SHA="${{ github.event.workflow_run.head_sha }}"
              SHORT="${SHA:0:7}"
              echo "IMAGE_TAG=${SHORT}" >> $GITHUB_ENV
              echo "No package.json found; using head sha short tag=${SHORT}"
            else
              echo "IMAGE_TAG=latest" >> $GITHUB_ENV
              echo "No package.json found and not a workflow_run; defaulting to 'latest'"
            fi
          fi

          echo "IMAGE=hsassa/api-auth:${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Install kubectl (v1.28.15)
        run: |
          set -e
          KUBECTL_VERSION="v1.28.15"
          echo "Installing kubectl ${KUBECTL_VERSION}"
          ARCH="$(uname -m)"
          case "$ARCH" in
            x86_64|amd64) BIN_ARCH=amd64 ;;
            aarch64|arm64) BIN_ARCH=arm64 ;;
            *) echo "Unsupported arch: $ARCH"; exit 1 ;;
          esac
          curl -fsSLO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/${BIN_ARCH}/kubectl"
          curl -fsSLO "https://dl.k8s.io/${KUBECTL_VERSION}/bin/linux/${BIN_ARCH}/kubectl.sha256"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check -
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Configure kubeconfig
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 --decode > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl version --client
          kubectl get ns realestate --ignore-not-found

      - name: Ensure deployment exists (apply manifests if missing) and update image
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          set -e
          if [ -z "${IMAGE_TAG}" ]; then
            echo "IMAGE_TAG is empty — aborting"
            exit 1
          fi

          # If deployment exists, we will update image; otherwise apply manifests
          if kubectl -n realestate get deployment api-auth >/dev/null 2>&1; then
            echo "Deployment api-auth exists in namespace realestate"
          else
            echo "Deployment api-auth not found — applying k8s manifests from k8s/"
            kubectl apply -f k8s/namespace.yaml
            kubectl apply -f k8s/api-auth-config.yaml || true
            kubectl apply -f k8s/api-auth-service.yaml || true
            kubectl apply -f k8s/api-auth-ingress.yaml || true

            # Check secret presence (the secret should be created beforehand or via a secure step)
            if ! kubectl -n realestate get secret api-auth-secrets >/dev/null 2>&1; then
              echo "ERROR: secret api-auth-secrets not found in namespace realestate."
              echo "Create it manually or add a secure creation step in the workflow."
              exit 1
            fi

            kubectl apply -f k8s/api-auth-deployment.yaml
            echo "Manifests applied"
          fi

          # Update image and bump template label so rollout occurs
          FULL_IMAGE="docker.io/hsassa/api-auth:${IMAGE_TAG}"
          echo "Setting image to ${FULL_IMAGE}"
          kubectl -n realestate set image deployment/api-auth api-auth=${FULL_IMAGE}
          kubectl -n realestate patch deployment api-auth -p "{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"version\":\"${IMAGE_TAG}\"}}}}}"
          kubectl -n realestate rollout status deployment/api-auth --timeout=180s

      - name: Verify pods
        run: |
          kubectl -n realestate get pods -l app=api-auth -o wide